# 手写代码

## JavaScript 基础

### debounce 防抖

> 本质上是优化高频率执行代码的一种手段
> 如：浏览器的 `resize`、`scoll`、`keypress`、`mousemove` 等时间在触发时会不断地调用绑定在时间上的回调函数，会极大地浪费资源，降低前端性能

**定义**: 函数防抖失职在时间被触发 n 秒后再执行回调，如果在这 n 秒内时间又被触发则重新计时

**用途**: 使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求(只执行最后一次，防止手抖点了多次 误)
**比喻**: 客梯等第一个人进来之后，等待 15s，如果这个过程中有其他人进来，则重新开始计时 15s，知道 15s 后开始运送
**原理**: 使用闭包创建一个函数，定义一个计时器，函数每次调用前清除计时器，也就是重新开始倒计时，然后通过`arguments` 获取到目标函数的参数，在 setTimeout 的回调中执行目标函数

```javascript
function debounce(fn, wait) {
  let timeout;
  return function () {
    let context = this;
    let args = arguments;
    // 在执行前重新倒计时
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn.apply(context, args);
    }, wait);
  };
}
```

```js
function debounce(fn, wait) {
  let timer = null;
  return function () {
    let context = this; // 获取this
    args = arguments; // 获取参数
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}
```

### throttle 节流

**定义**： 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一单位时间内某时间被多次触发，只能用一次生效。

**用途**：scrool 函数的时间监听，通过事件节流降低事件调用的频率。
**比喻**: 客梯进入第一个人之后开始计时，15s 后开始运送（准时的，管你后面会不会有人再进来，到点开车！）
**原理**: 利用闭包函数，创建一个函数，在调用时创建一个计时器，计时器到点之后执行

```js
function throttle(target, delay) {
  let curTime = Date.now();
  return function () {
    let context = this;
    args = arguments;
    nowTime = Date.now();
    if (nowTime - curTime >= delay) {
      curTime = nowTime;
      fn.apply(context, args);
    }
  };
}
```

### call

call 函数实现步骤：

1. 判断调用对象是否为函数，即我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
2. 判断传入上下文对象是否存在，不存在这设置为 `window`。
3. 处理传入的参数，截取第一个参数后的所有参数。
4. 将函数作为上下文对象的一个属性。
5. 是噢那个上下文对象来调用这个方法，并保存返回结果。
6. 删除刚才新增的属性。
7. 返回结果

```js
Function.prototype..myCall = function(context) {
    // 判断调用对象
    if (typeof this! == 'function') {
        console.error('type error: ')
    }
    // 获取参数
    let args = [...arguments].slice(1),
        result = null
    // 判断 context 是否传入，如果为传入设置为 window
    context = context || window
    // 将调用函数这是为对象的方法
    context.fn = this
    result = context.fn(...args)
    delete context.fn()
    return result

}
```

### apply

apply 函数实现步骤：

1. 判断调用对象是否为函数，即我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
2. 判断传入上下文对象是否存在，不存在这设置为 `window`。
3. 处理传入的参数，截取第一个参数后的所有参数。
4. 将函数作为上下文对象的一个属性。
5. 是噢那个上下文对象来调用这个方法，并保存返回结果。
6. 删除刚才新增的属性。
7. 返回结果

```javascript
Function.prototype.MyApply = function (context) {
  if (typeof context === 'function') {
    throw new TypeError(context);
  }
  let result = null;
  context = context || window;
  conext.fn = this;
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

### bind

bind 函数的实现步骤

1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
2. 保存当前函数的引用，获取其余传入参数值。
3. 创建一个函数返回结果
4. 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

```js
Function.prototype..MyBind = function(context) {
    if (typeof context === 'function') {
        throw new TypeError(context)
    }
    var args = [...arguments].slice(1),
        fn = this
    return function Fn() {
        return fn.apply(
            this instanceof Fn ? this : context,
            args.concat(...arguments)
        )
    }
}
```

### 函数柯里化

函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。
**ES5**

```js
function curry(fn, args) {
  let length = fn.length;
  args = args || [];
  return function () {
    let subArgs = args.slice(0);
    for (let i = 0; i < argument.length; i++) {
      subArgs.push(argument[i]);
    }
    if (subArgs.length >= length) {
      return fn.apply(this, subArgs);
    } else {
      return fn.apply(this, fn, subArgs);
    }
  };
}
```

**ES6**

```js
function curry(fn, ...args) {
    return fn.length <= args.length ? fn(...args) : fn.bind(null, fn, ...args) >
}
```

### 浅拷贝

浅拷贝是指一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会随之变化。

`**Object.assign()**

`Object.assgin()` 是 ES6 中对象的拷贝方法，接受的第一个参数是目标对象，其余参数为源对象。

语法： `Object.assign(target, source1, source2)` 。

该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。

注意：

- 如果目标对象与源对象有同名属性，或者多个源对象，则后面的属性会覆盖前面的属性。
- 如果函数只有一个参数，当参数为对象时，直接返回该对象，当参数不是对象时，会先将参数转换成对象返回。
- 因为 `null` `undefined` 不能转为对象，所以第一个参数不能为 `null` 或 `undefined`，否则会报错

```js
let target = {
  a: 1,
};
let object2 = {
  b: 2,
};
let object3 = {
  c: 3,
};
Object.assign(target, object2, object3);
console.log(target); // {a: 1, b: 2, c: 3}
```

**扩展运算符**

使用扩展运算符可以在构建字面量对象的时候进行属性的拷贝。

语法： `let cloneObj = {...object}`

```js
let obj1 = {
  a: 1,
  b: {
    c: 1,
  },
};
let obj2 = {
  ...obj1,
};
obj1.a = 2;
console.log(obj1); //{a:2,b:{c:1}}
console.log(obj2); //{a:1,b:{c:1}}
obj1.b.c = 2;
console.log(obj1); //{a:2,b:{c:2}}
console.log(obj2); //{a:1,b:{c:2}}
```

**数组方法实现浅拷贝**

1. Array.prototype.slice()

- `slice()` 方法是数组的一个 API，这个方法可以从已有数组中返回选定的元素
- 用法：`array.slice(start, end)`

两个参数都不写可以实现数组的浅拷贝

```js
let arr = [1, 2, 3, 4];
console.log(arr.slice()); // [1,2,3,4]
console.log(arr.slice() === arr); //false
```

2. Array.prototype.concat()

- `concat()` 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。
- 该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。

```js
let arr = [1, 2, 3, 4];
console.log(arr.concat()); // [1,2,3,4]
console.log(arr.concat() === arr); //false
```

**手写浅拷贝**

```js
function shallowCopy(Object) {
  if (!object || typeof object !== 'object') return;
  let newObject = Array.isArray(object) ? [] : {};
  for (let key in object) {
    if ((object, hasOwnProperty(key))) {
      newObject[key] = object[key];
    }
  }
  return newObject;
}
```

### 深拷贝

浅拷贝相对于深拷贝而言，遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以属性值里面如果出现函数或者是 Symbol 类型的时候，会转换失败

**JSON**

- 原理：利用 `JSON.stringify` 将 `js` 对象序列化（JSON 字符串），在使用 `JSON.parse()` 来反序列化 `js` 对象
- 缺陷：拷贝对象中有函数、undefined、 symbol 时，序列化后会消失
- 用法：`JSON.parse(JSON.stringify(obj))`

```js
let obj1 = {
  a: 0,
  b: {
    c: 0,
  },
};
let obj2 = JSON.parse(JSON.stringify(obj1));
obj1.a = 1;
obj1.b.c = 1;
console.log(obj1); // {a: 1, b: {c: 1}}
console.log(obj2); // {a: 0, b: {c: 0}}
```

**lodsh.\_cloneDeep**

```js
var _ = require('lodash');
var obj1 = {
  a: 1,
  b: {
    f: {
      g: 1,
    },
  },
  c: [1, 2, 3],
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**手写深拷贝**

```js
function deepCopy(obj) {
  if (!obj || typeof obj !== 'object') return;
  let newObject = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObject[key] =
        typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; // 遇到对象递归拷贝
    }
  }
  return newObject;
}
```

## 数据处理

### 交换 a, b 的值，不能使用临时变量

```js
a = a + b;
b = a - b;
a = a - b;
```

### 实现数组的乱序输出

思路：

- 去除数组的第一个元素，随机产生一个索引值，经第一个元素和这个索引对应的袁术进行交换
- 第二次取出的元素，随意产生一个除了索引为 1 以外的索引值，并将第二个元素与该索引值对应的元素进行交换
- 按照上面的规律执行，知道遍历完成
  **方法一**

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
for (let i = 0; i < arr.length; i++) {
  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;
  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];
}
console.log(arr);
```

**方法二**

倒序遍历

```js
var arr = [1, 2, 3, 4];
let length = arr.length,
  randomIndex,
  temp;
while (length) {
  randomIndex = Math.floor(Math.random() * length--);
  temp = arr[length];
  arr[randomIndex] = temp;
}
console.log(arr);
```

### 数组求和

**一维数组**

- reduce

```js
let arr = [1, 2, 3, 4];
let sum = arr.reduce((total, i) => (total += i), 0);
```

- 递归

```js
var arr = [1, 2, 3, 4];

function sum(arr) {
  if (arr.length == 1) {
    return arr[0];
  }
  return arr[0] + add(arr.slice(1));
}
console.log(add(arr));
```

**二维数组**

```js
var = arr = [1, 2, 3, [
    [4, 5], 6
], 7, 8, 9];
let arr = arr.toString().split(',').reduce((total, i) => total += i, 0);
```

### 数组扁平化

**递归**

```js
let arr = [1, [2, [3, 4, 5]]];

function flatten(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
flatten(arr);
```

**reduce**

```js
function flatten(arr) {
    return add.reduce(function(prev, next) {
        return prev.concat(Array.isArray(next) ? flatten(new) : next);
    }, [])
}
```

**扩展运算符**

```js
let arr = [1, [2, [3, [4, [5]]]];

    function flatten(arr) {
        while (arr.some((item) => Array.isArray(item))) {
            arr = [].concat(...arr)
        })) {
    result arr
}
}
```

**split 和 toString**

```js
var arr = [1, [2, [3, [4, [5, [6]]]]];

        function flatten(arr) {
            return arr.toString().split(',')
        }
        flatten(arr)
```

**ES6 flat**

```js
var arr = [1, [2, [3, [4, [5, [6]]]]];
        arr.flat(Infinity)
```
