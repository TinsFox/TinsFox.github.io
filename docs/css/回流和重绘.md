# 重绘和回流

> https://juejin.cn/post/6999814680986255397

> 在 html 中，每个元素都可以理解为一个盒子，在浏览器解析的过程中，会涉及到回流与重绘

- 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置
- 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制

浏览器渲染机制

![image-20210826150515360](https://pic.tinsfox.com/uPic/image-20210826150515360.png)

- 解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树
- 讲 DOM 树和 CSSOM 树结合，生成渲染树（Render Tree）
- Layout（回流）：根据生成的渲染书，进行回流，得到节点的几何信息（位置、大小）
- Painting（重绘）：根据渲染书以及回流得到的几何信息，得到节点的绝对像素
- Display：将像素发送给 GPU，展示在页面上

在页面的初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素，使页面布局发生改变。

当我们对 DOM 的修改印发了 DOM 几何尺寸的变化（比如修改元素的宽高、显隐）时，浏览器需要重新计算元素的集合属性，然后再将计算的结果绘制出来。

当我们对 DOM 的修改导致了样式的变化（color、background-color），却并未影响其集合属性时，浏览器不需要重新计算元素的几何样式，直接为该元素绘制新的样式，这里只会触发重绘。

### 触发时机

##### 回流

> 这一阶段主要时计算节点的位置和集合信息，那么当页面布局和几个信息发生变化时，就需要回流

- 添加或删除课件的 DOM 元素

- 元素的位置发生变化

- 元素的尺寸发生变化（包括外边距、内边距、边框大小、高度、宽度等）

- 内容发生变化，比如文本变化或者图片被另一个不同尺寸的图片替代

- 页面初次渲染

- 浏览器的窗口尺寸变化（回流时根据视口的大小来计算元素的位置和大小的）

- 获取特定值：offsetTop、offsetLeft、、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight

  > 这些属性都有一个共性，就是需要通过即时计算得到，因此浏览器为了获取这些值吗也会进行回流，除此还包括 getComputedStyle 方法

##### 重绘

可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵花从左边移动了右边，那么我们就要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）。

- 回流必定触发重绘
- 颜色的修改
- 文本方向的修改
- 阴影的修改

### 浏览器优化机制

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放到队列里，知道过了一段时间或者操作达到了一个阀值，才会清空队列。当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的 offsetTop 等方法都会返回最新的数据。因此浏览器不得不清空队列，触发回流重绘来返回正确的值。

### 优化手段

- 如果想设定元素的样式，通过改变元素的 class 的类名（尽可能在 DOM 树的最里层）
- 避免设置多项内联样式
- 应用元素的动画，使用 `position` 属性的`fixed` 值或者 `absolute` 值，
- 避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算
- 对于复杂的动画，对其设置 `position : fixed/ absloute` ，尽可能地使元素脱离文档流，从而减少对其他元素的影响
- 使用 CSS3 硬件加速，可以让`transform` 、 `opacity` 、`filters` 这些动画不会引起回流重绘
- 避免使用 css 的 JavaScript 表达式
